跳到内容
 
Search or jump to…

拉请求
问题
市井
探索
 
@yangdebang 
1
0 0 www123www / c-code
 代码 问题0 拉取请求0 项目 0 Wiki 见解   
c-code /实验5代码 /1661200127黄忠胜.txt
@HuangZhongS HuangZhongS 通过上传
eb6bf49 添加文件
3 days ago
131行（131 sloc）  3.53 KB
    
#include <iostream>
#include <conio.h>
#include <stdlib.h>
using namespace std;
typedef int ElemType;
struct NodeType //定义结点结构体
{
	ElemType数据;
	NodeType * lch，* rch;
};
class BiTree //定义二叉树类
{
上市：
	BiTree（）{root = NULL; }; //构造函数
	~BiotT（）{destroy（root）; } //析构函数
	void inorder（）//中序遍历
	{
		序（根）;
	}
	void preordertswap（）//利用先序遍历方法交换左右子树
	{
		preorderswap（根）;
	}
	int tleaf（）//求中叶子节点的个数
	{
		返回叶子（根）;
	}
	void creat0（）;
私人的：
	NodeType * root; //数据成员，树根
	NodeType * creat（）; //建立二叉树递归方法
	void inorder（NodeType * p）; //中序遍历
	void preorderswap（NodeType * p）; //利用先序遍历方法交换左右子树
	int leaf（NodeType * p）; //求二叉树中叶子节点的个数
	void destroy（NodeType *＆p）; //删除二叉树所有结点
};
void BiTree :: creat0（）//建立树函数，
{
	cout <<“请按照树的先序遍历顺序组织数据”<< endl;
	cout <<“若结点信息是int，把每个结点的空孩子以0输入;” << endl;
	cout <<“一个结点的二叉树11，输入：11 0 0;” << endl;
	root = creat（）; //调用私有穿心莲（）;
}
NodeType * BiTree :: creat（）//递递建立二叉树算法
{
	NodeType * p; ElemType x;
	cout <<“\ n输入数据：”; cin >> x;
	if（x == 0）p = NULL;
	其他{
		p =新的NodeType; p-> data = x;
		p-> lch = creat（）; //递归调用自身
		p-> rch = creat（）;
	}
	返回p;
}
void BiTree :: inorder（NodeType * p）//中序遍历
{
	if（p！= NULL）
	{
		序（对 - > LCH）;
		cout << p-> data <<“”;
		序（对 - > RCH）;
	}
}
void BiTree :: preorderswap（NodeType * p）//利用先序遍历方法交换左右子树
{
	if（p！= NULL）
	{
		NodeType * r; r = p-> lch;
		p-> lch = p-> rch; p-> rch = r;
		//上面几条语句可以认为对结点的访问（交换左右孩子）
		//替换了原来的：cout << p-> data <<“”; 语句
		preorderswap（对 - > LCH）;
		preorderswap（对 - > RCH）;
	}
}
void BiTree :: destroy（NodeType *＆p）//删除二叉树所有结点
{
	if（p！= NULL）
	{
		破坏（对 - > LCH）;
		破坏（对 - > RCH）;
		删除p;
		p = NULL;
	}
}
int BiTree :: leaf（NodeType * p）//求二叉树中叶子节点的个数
{
	if (p == NULL)
	{
		return 0;
	}
	if (p->lch == NULL && p->rch == NULL)
	{
		return 1;
	}
	return leaf(p->lch) + leaf(p->rch);
}
//---------------------------------------------------------------------------
int main()
{
	int k;     BiTree root0;                     //声明创建二叉树对象，调用构造函数
	do {
		cout << "\n\n";
		cout << "\n\n     1. 建立二叉树";
		cout << "\n\n     2. 交换左右子树 ";
		cout << "\n\n     3. 求二叉树中叶子节点的个数  ";
		cout << "\n\n     4. 结束程序运行";
		cout << "\n======================================";
		cout << "\n     请输入您的选择 (0,1,2,3,4):"; cin >> k;
		switch (k)
		{
		case 1: {  cout << "\n  s输入（0 0）结束：";
			root0.creat0();
			cout << "\n     中先根遍历结果：";  root0.inorder();
		} break;
		案例2：{cout <<“\ n交换左右子树结果：”;
			root0.preordertswap（）;
			cout <<“\ n中先根遍历结果：”;
			root0.inorder（）;
		打破
		案例3：{int number;
			number = root0.tleaf（）;
			cout <<“\ n叶子节点的个数是：”<<数字;
		打破
		案例4：退出（0）;
		} //开关
		cout <<“\ n ----------------”;
	} while（k> = 0 && k <4）;
	_getch（）; 返回0;
} // -----  
©2019 GitHub，Inc。
条款
隐私
安全
状态
救命
联系GitHub
价钱
API
训练
博客
关于
